- Exercicio 1: Boublesort

Resolução: Foi criado um Vetor de 10000 posições por uma função CriaVetor depois passou por uma função Bubblesort aonde foi feita a ordenação e por fim o vetor foi exibido por uma função MostraVetor. A função Bubblesort consiste em ordenar os valores em forma decrescente, então, a posição atual é comparada com a próxima posição e, se a posição atual for maior que a posição posterior, é realizada a troca dos valores nessa posição.

Print da Resolução: ![Print_Laboratorio6_Exericio1_AnaClaraBertoldoAnastacio](https://user-images.githubusercontent.com/101759772/195471829-03381998-17d3-49b1-80ec-8aa622556321.jpg)

Gráfico da Resolução: ![Exercicio1_Laboratorio6_AnaClaraBertoldo](https://user-images.githubusercontent.com/101759772/195648264-f4cd5b88-ca74-49e7-a125-e4f6c6ff0073.jpg)

- Exercicio 2: InsertionSort

Resolução: Foi criado um Vetor de 10000 posições por uma função CriaVetor depois passou por uma função InsertionSort aonde foi feita a ordenação e por fim o vetor foi exibido por uma função MostraVetor. A função Insertion Sort ou ordenação por inserção é o método que percorre um vetor de elementos da esquerda para a direita e à medida que avança vai ordenando os elementos à esquerda. Possui complexidade C(n) = O(n) no melhor caso e C(n) = O(n²) no caso médio e pior caso. É considerado um método de ordenação estável.

Print da Resolução: ![Print da Resolução - InsertionSort - Ana Clara Bertoldo A Pereira](https://user-images.githubusercontent.com/101759772/195649867-e492183f-fd64-4f3c-971c-a794bebfa034.png)


Gráfico da Resolução: ![Exercicio2_Laboratorio6_AnaClaraBertoldo](https://user-images.githubusercontent.com/101759772/195650230-f086b6c0-0867-4a6f-8293-5db0e5802f83.jpg)

- Exercicio 3: MergeSort

Resolução: Foi criado um Vetor de 10000 posições por uma função criaVetor depois passou por uma função MergeSort aonde foi feita a ordenação e por fim o vetor foi exibido por uma função MostraVetor. A função Merge Sort é um algoritmo eficiente de ordenação por divisão e conquista. Se nossa missão é ordenar um array comparando seus elementos, do ponto de vista assintótico, n∗logn é o nosso limite inferior. Ou seja, nenhum algoritmo de ordenação por comparação é mais veloz do que n∗logn. Formalmente, todos são Ω(n∗logn).

Print da Resolução: ![Print da Resolução - MergeSort - Ana Clara Bertoldo A Pereira](https://user-images.githubusercontent.com/101759772/195651027-a0fb42bc-31c7-4bef-aba7-b7a64758d01c.jpg)

Gráfico da Resolução: ![Exercicio3_Laboratorio6_AnaClaraBertoldo](https://user-images.githubusercontent.com/101759772/195651192-2b6dfc73-9912-4e74-bb1b-36062579f2a3.jpg)

